# TaskFlow Pro - Advanced Task Management System

A scalable REST API with authentication & role-based access, featuring a dark-themed frontend UI for testing the APIs.

## ✅ Core Features Implemented

### Backend (Primary Focus)
- ✅ User registration & login APIs with password hashing and token authentication
- ✅ Role-based access control (user vs admin)
- ✅ CRUD APIs for tasks (secondary entity)
- ✅ API versioning, comprehensive error handling, and validation
- ✅ Interactive API documentation with Swagger UI
- ✅ Database schema with Django ORM and migrations
- ✅ Secure token-based authentication

### Frontend (Supportive)
- ✅ Built with React.js + Vite
- ✅ Simple UI for user registration & login
- ✅ Protected dashboard requiring authentication
- ✅ Full CRUD operations on tasks
- ✅ Error/success messages from API responses
- ✅ Responsive design for all device sizes

### Security & Scalability
- ✅ Secure token handling and storage
- ✅ Input sanitization & validation
- ✅ Scalable project structure for new modules
- ✅ CORS configuration for cross-origin requests
- ✅ Docker support for easy deployment

## 🛠 Technologies Used

### Backend
- Python 3.x
- Django 5.2.6
- Django REST Framework 3.16.1
- SQLite (development) / PostgreSQL (production)
- drf-yasg for Swagger documentation
- django-cors-headers for CORS support

### Frontend
- React.js 18+
- Vite for ultra-fast development
- Axios for HTTP requests
- Modern CSS with animations

## 🚀 Setup Instructions

### Prerequisites
- Python 3.8+
- Node.js 16+
- PostgreSQL (optional, SQLite used by default for development)

### Backend Setup

1. Clone the repository
2. Navigate to the project directory
3. Create a virtual environment:
   ```bash
   python -m venv venv
   ```
4. Activate the virtual environment:
   - On Windows: `venv\Scripts\Activate.ps1`
   - On macOS/Linux: `source venv/bin/activate`
5. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```
6. Run migrations:
   ```bash
   python manage.py migrate
   ```
7. Create a superuser (optional):
   ```bash
   python manage.py createsuperuser
   ```
8. Start the development server:
   ```bash
   python manage.py runserver
   ```

### Frontend Setup

1. Navigate to the frontend directory:
   ```bash
   cd frontend
   ```
2. Install dependencies:
   ```bash
   npm install
   ```
3. Start the development server:
   ```bash
   npm run dev
   ```

## 📡 API Endpoints

### User Management
- `POST /api/v1/users/register/` - Register a new user
- `POST /api/v1/users/login/` - Login user

### Task Management
- `GET /api/v1/tasks/` - List all tasks (users see their own, admins see all)
- `POST /api/v1/tasks/` - Create a new task
- `GET /api/v1/tasks/{id}/` - Retrieve a specific task
- `PUT /api/v1/tasks/{id}/` - Update a specific task
- `PATCH /api/v1/tasks/{id}/` - Partially update a specific task
- `DELETE /api/v1/tasks/{id}/` - Delete a specific task

### API Documentation
- `GET /swagger/` - Interactive API documentation

## 📁 Project Structure

```
backend_assignment/
├── backend_assignment/     # Django project settings
├── users/                  # User management app
├── tasks/                  # Task management app
├── manage.py              # Django management script
├── requirements.txt       # Python dependencies
├── .env                   # Environment variables
├── .gitignore             # Git ignore rules
├── Dockerfile             # Docker configuration for backend
├── docker-compose.yml     # Multi-container Docker setup
├── frontend/              # React frontend
│   ├── src/               # React source code
│   ├── public/            # Static assets
│   └── package.json       # Frontend dependencies
└── README.md              # This file
```

## 🔐 Role-Based Access Control

- **Users**: Can only access their own tasks
- **Admins**: Can access all tasks and have additional privileges

## 🐳 Docker Deployment

### Using Docker Compose (Recommended)
```bash
docker-compose up --build
```

This will start:
- Backend on port 8000
- Frontend on port 5173
- PostgreSQL database on port 5432

### Individual Container Deployment
```bash
# Build and run backend
docker build -t taskflow-backend .
docker run -p 8000:8000 taskflow-backend

# Build and run frontend
cd frontend
docker build -t taskflow-frontend .
docker run -p 5173:5173 taskflow-frontend
```

## 🧪 Testing

Run the test suite:
```bash
python manage.py test
```

## 📊 Database Management

TaskFlow Pro uses Django's built-in ORM and migration system:

1. **Models**: Data structure defined in Python classes
2. **Migrations**: Automatically generated by Django
3. **Commands**: 
   - `python manage.py makemigrations` - Create new migrations
   - `python manage.py migrate` - Apply migrations to database

Django automatically handles:
- Table creation
- Schema updates
- Index creation
- Relationship management
- Data validation

## 📚 API Documentation

### Swagger UI
Access the interactive API documentation at:
```
http://localhost:8000/swagger/
```

### Postman Collection
You can import the Postman collection from the `docs/` directory to test the APIs.

Key API features:
- **Authentication**: Token-based authentication for all protected endpoints
- **Validation**: Comprehensive input validation with descriptive error messages
- **Error Handling**: Consistent error response format with HTTP status codes
- **Pagination**: Automatic pagination for list endpoints
- **Filtering**: Task list can be filtered by completion status

## 🚀 Scalability & Performance

### Current Architecture
The application follows a monolithic architecture with clear separation between frontend and backend components.

### Scalability Strategies

#### 1. Microservices Architecture
For future scaling, the application can be decomposed into microservices:
- **User Service**: Handle authentication and user management
- **Task Service**: Manage task creation, retrieval, and updates
- **Notification Service**: Handle email/SMS notifications
- **Analytics Service**: Provide insights and reporting

#### 2. Caching Strategy
Implement Redis caching for:
- User session data
- Frequently accessed tasks
- API response caching for read-heavy operations

#### 3. Load Balancing
Deploy multiple instances behind a load balancer:
- Use NGINX or HAProxy for load distribution
- Implement sticky sessions for WebSocket connections (if added)
- Horizontal scaling of application instances

#### 4. Database Optimization
- Implement read replicas for PostgreSQL
- Add database connection pooling
- Use database indexing for frequently queried fields
- Consider database sharding for very large datasets

#### 5. CDN Integration
- Serve static assets through a CDN
- Cache frontend assets at edge locations
- Reduce latency for global users

#### 6. Asynchronous Processing
- Use Celery with Redis/RabbitMQ for background tasks
- Offload email notifications to background workers
- Process file uploads asynchronously

### Monitoring & Observability
- Implement application performance monitoring (APM)
- Add logging aggregation with ELK stack
- Set up health checks and alerting
- Monitor database performance and query optimization

## 🛡️ Security Practices

### Authentication & Authorization
- Token-based authentication with secure storage
- Role-based access control (RBAC)
- Password hashing with PBKDF2 algorithm
- Session management and timeout handling

### Data Protection
- Input validation and sanitization
- SQL injection prevention through ORM
- Cross-site scripting (XSS) protection
- Cross-site request forgery (CSRF) protection

### API Security
- Rate limiting to prevent abuse
- Secure headers implementation
- HTTPS enforcement in production
- CORS configuration for controlled access

## 📈 Future Enhancements

- [ ] Implement Redis caching for improved performance
- [ ] Add comprehensive logging functionality
- [ ] Enhance API documentation with examples
- [ ] Implement unit tests for both backend and frontend
- [ ] Add real-time notifications
- [ ] Implement task sharing between users
- [ ] Add task categories and priorities
- [ ] Create mobile-responsive design enhancements

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🤝 Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a pull request

## 📞 Support

For support, email support@taskflowpro.com or open an issue in the repository.